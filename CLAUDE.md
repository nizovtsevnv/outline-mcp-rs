Ты профессиональный архитектор программного обеспечения, Rust разработчик, тестировщик, DevOps инженер.

## Технические требования к среде разработки

### Инструменты разработки, тестирования и сборки
- Воспроизводимое окружение разработки Nix;
- Система контроля версий Git;
- Язык программирования Rust со стандартом 2024 edition;
- Rust Crates наиболее свежих версий;
- Инструмент настройки проекта, регулирования зависимостей, сборки, автоформатирования и автотестирования (Cargo)
- Вспомогательные анализаторы (Clippy, Rust Analyzer)
- Shell скрипты для автоматизации сложных повторяющихся задач;
- IDE (например, Zed);
- AI Агенты (например, Claude Code).

### Воспроизводимое окружение разработки Nix

Для обеспечения воспроизводимой среды разработки и тестирования используйте пакетный менеджер Nix.

Вход в воспроизводимое окружение разработки производится командой `nix develop`.
В NixOS без Nix Flakes вход производится командой `nix develop --extra-experimental-features flakes --extra-experimental-features nix-command`.
Также доступна возможность запуска любой команды в воспроизводимом окружении разработки с помощью команды **nix develop -c <ВАША_КОМАНДА>** (например, `nix develop -c cargo test`).

После входа в среду Nix, системное окружение будет использовать зависимости, определенные в файле "flake.nix".

## Архитектурные принципы

### Принципы проектирования
- **Separation of Concerns** - Разделение системы на отдельные и непересекающиеся по функциональности модули
- **Resilience** - Способность системы быстро восстанавливаться после сбоев
- **Parallel Execution** - Распределение задач для одновременного выполнения
- **Cohesion & Coupling** - Элементы модуля сильно связаны друг с другом, поскольку работают над одним и тем же функционалом
- **Composition over Inheritance** - Композиция объектов предпочтительнее наследования для лучшей гибкости
- **Open/Closed Principle** - Модули должны быть открыты для расширения, но закрыты для модификации
- **Dependency Inversion Principle** - Модули высокого уровня не должны зависеть от модулей низкого уровня, оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей, детали должны зависеть от абстракций.
- **Decoupling** - Разделение модулей на независимые части для лучшей гибкости и расширяемости с использованием правила "одна структура - один файл"
- **KISS** (Keep It Simple)
- **DRY** (Don't Repeat Yourself) - избегаем дублирования кода
- **Error Handling** - правильная обработка ошибок через Result<T, E>
- **Memory Safety** - использование возможностей Rust для безопасности памяти
- Разрабатываемая система должна быть по-возможности минималистичной, логически полной и самодостаточной, легко поддерживаемой и масштабируемой, покрытой тестами и документацией.

## Стандарты кодирования и документирования кода

### Стандарты кодирования Rust
- Избегайте присутствия мёртвого кода;
- Следуйте стандартам форматирования кода `cargo fmt`;
- Используйте `cargo clippy` для проверки качества кода;
- Используйте `#[derive(Debug)]` для всех структур;
- Предпочитайте `&str` вместо `String` для параметров функций;
- Используйте `Result<T, E>` для функций, которые могут завершиться ошибкой.
- Стандарты именования:
  - `snake_case` для функций, переменных, модулей
  - `PascalCase` для структур, энумов, трейтов
  - `SCREAMING_SNAKE_CASE` для констант
  - Осмысленные имена, отражающие назначение
- Всегда следуй правилу декомпозиции "1 структура - 1 файл"
- Автоматизирующие переиспользуемые SH-скрипты располагайте в каталоге "scripts"
- Временные скрипты располагайте в каталоге "temp"

### Стандарты документирования Rust
- Основной формат документирования **RustDocs**, для описания API **OpenAPI**;
- **Markdown** для форматирования текста документации;
- Синхронизация документации с кодовой базой;
- Должны документироваться:
  - Публичные функции и структуры данных;
   должны быть документированы в формате **RustDoc**, а публичные API в формате **OpenAPI**;
  - Конфигурационные параметры;
  - Ошибки и исключения;

## Стандарты логирования и отладки

### Отладка
- Используйте `RUST_LOG` для настройки уровня логирования
- Предпочитайте логирование debug! вместо println! для отладки
- Используйте `rust-gdb` или `lldb` для глубокой отладки

### Логирование
- Используйте tracing для структурированного логирования
- Уровни логирования: `error`, `warn`, `info`, `debug`, `trace`
- Не логируйте чувствительную информацию (пароли, токены)

## Стандарты тестирования

### Основные требования
- Минимальное покрытие тестами: 80%
- Все публичные функции должны быть покрыты тестами
- Критичные функции безопасности требуют 100% покрытия

### Типы тестов
1. **Unit тесты** - тестирование отдельных функций и модулей
2. **Integration тесты** - тестирование взаимодействия между модулями
3. **End-to-end тесты** - тестирование через gRPC API

### Структура тестов
```
tests/
├── integration/        # Интеграционные тесты
│   ├── some_mod1_tests.rs
│   ├── some_mod2_tests.rs
│   └── common/
│       └── mod.rs     # Общие утилиты для тестов
└── e2e/               # End-to-end тесты
    └── some_mod3_tests.rs
```

## Стандарты безопасности

### Основные требования:
- Никогда не коммитить секреты, ключи, пароли
- Использовать переменные окружения для конфиденциальных данных
- Валидировать все входящие данные
- Использовать prepared statements для работы с БД
- Регулярно обновлять зависимости

### Проверка безопасности:
```bash
# Аудит зависимостей
cargo audit

# Проверка на уязвимости
cargo deny check
```
